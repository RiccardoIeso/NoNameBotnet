#!/usr/bin/env python3

from twisted.internet import protocol, reactor, endpoints
from twisted.internet.task import LoopingCall

#Messages for the clients
c_message = {} 
#Messages for the master
m_message = []
#List of ip connected
ip_list = []
#Number of connected clients
cnt_clients = 0

class echoClient(protocol.Protocol):
    def __init__(self, factory):
        self.factory = factory

    def connectionMade(self):
        global cnt_clients
        global ip_list
        self.peer_host = self.transport.getPeer().host
        self.peer_port = self.transport.getPeer().port
        self.hostport = ''.join([self.peer_host, str(self.peer_port)])
        self.factory.clients[self.hostport] = self
        ip_list.append(self.hostport)
        print('[*]Client %s:%s connected' %(self.peer_host, self.peer_port))
        cnt_clients += 1
        print('[%s]Clients status' %(cnt_clients))		

    def connectionLost(self, reason):
        global cnt_clients
        global ip_list
        cnt_clients -= 1
        self.factory.clients.pop(self.hostport, None)
        ip_list.remove(self.hostport)  
        print('[*] Client %s:%s disconnected' %(self.peer_host, self.peer_port))
        print('[%s] Client status ' %(cnt_clients))
    
    def dataReceived(self, data):
        print("[DEBUG] Data received from [%s] -> [%s]" %(self.peer_host, data))
        global m_message
        data = data.decode('utf-8', 'ignore')
        #Extract data from json
        #for command, response in data.items():
        #    m_message[command] = response		
        print(data) 
        #[TEST ONLY] --> STRING
        m_message.append(data)

class clientFactory(protocol.Factory):
    def __init__(self):
        self.clients = {}
        
        def broadcast_msg():
            global c_message
            rmList = []
            if c_message:
                print('message %s' %(c_message))
                for ip, msg in c_message.items():
                    for bip, connection in self.clients.items():
                        #Check if the ip i want to send the message is active
                        if ip == bip:
                            rmList.append(ip)
                            self.clients[bip].transport.write(msg.encode('utf-8'))
                if rmList:
                    for ip in rmList:
                        c_message.pop(ip, None)

        self.looping_call = LoopingCall(broadcast_msg)
        self.looping_call.start(0.1)

    def buildProtocol(self, addr):
        return echoClient(self)

class echoMaster(protocol.Protocol):
    def connectionMade(self):
        self.master_host = self.transport.getPeer().host
        print('*- Master [%s] connected -*' %(self.master_host))
       # send_ip = ":".join(ip_list)
       # self.transport.write(send_ip.encode('utf-8'))

    def connectionLost(self, reason):
        print('*- Master [%s] disconnected -*' %(self.master_host))

    def dataReceived(self, data):
        global c_message
        global ip_list
        data = data.decode('utf-8')
        if '*' in data:
            p_data = data.split('*')
            peer_ip = p_data[0]
            peer_msg = p_data[1]
            if peer_ip != 'null':
                c_message[peer_ip] = peer_msg
                print('[DEBUG] Message for bot [%s]' %c_message)
                self.startBroadcast()
            else:
                send_ip = ':'.join(ip_list)
                self.transport.write(send_ip.encode('utf-8'))
        else:
            pass

    def startBroadcast(self): 
        def broadcast():
            global m_message
            rmList = []
            if m_message:
                for msg in m_message:
                    self.transport.write(msg.encode('utf-8')) 
                    rmList.append(msg)
                for ms in rmList:
                    m_message.remove(ms)
                    looping_call.stop()
        looping_call = LoopingCall(broadcast)
        looping_call.start(0.1)

class masterFactory(protocol.Factory):
    def buildProtocol(self, addr):
        return echoMaster()
 
if __name__ == '__main__': 
    endpoints.serverFromString(reactor, "tcp:8081:interface=167.99.194.11").listen(clientFactory())
    endpoints.serverFromString(reactor, "tcp:8080:interface=167.99.194.11").listen(masterFactory())
    reactor.run()
